class DataDomain():


    current_autosupport_name="" # Contains the name of the autosupport from which the DataDomain object is build
    current_autosupport_content=[] # Contains a list with the current autosupport in memory (one line per entry)
    lrepl_client_time_stats=[] # Contains the part of the autosupport that is related with Lrepl Client Time Stats
    replication_contexts=[] # A list of dictionaries were each dictionary contains all the information of a replication context
    num_of_replication_contexts=0 # This attribute contains the total number of replication contexts in the DataDomain

   # Constructor
    def __init__(self,current_autosupport_name):
        self.current_autosupport_name=current_autosupport_name
        with open (self.current_autosupport_name) as autosupport_fd:
            self.current_autosupport_content=autosupport_fd.read().splitlines() # splitlines removes the \n from each line. We have now in self.current_autosupport_content the full autosupport

            self.populate_replication_contexts() # We call the method to populate the replication_contexts list of dictionaries
            self.populate_lrepl_client_time_stats("Lrepl client time stats","Lrepl client stream stats") # We call the method to populate the lrep_client_time_stats, indicating the delimitors in the autosupport that this information spreads

    # Object methods
   # This function method populates the replication_contexts class object with information about the replication contexts
    def populate_replication_contexts(self):

        context={} # Dictionary that contains one specific context that has being read from the autosupport
        #Example
        #context={'ctx_number':'0','src_host':'dd640.datadomain.com','src_path':'/data/col1/source','dst_host':'dd890.datadomain.com','dst_path':'/data/col1/destination'}

        context_list=[] # A list of contexts, each of them being a dictionary
        self.replication_contexts=[]

        for i,autosupport_read_line in enumerate(self.current_autosupport_content): # We read from all the autosupport
            if(len(autosupport_read_line)!=0): # If the line is empty we discard it
                if 'repl.' in autosupport_read_line and ('src_' in autosupport_read_line or 'dst_' in autosupport_read_line): # If it contains information about context (both source and destination)
                    #Example of what is inside autosupport_read_line
                    #repl.001.dst_host = DD7200-1-SH.localdomain
                    #repl.001.src_path = /data/col1/replication1
                    context_list=autosupport_read_line.split('=') #We split by the symbol =
                    if 'repl' in context_list[0]: # There is always repl, we just want to obtain the replication context
                        w=context_list[0].split('.') # We split the first part by the symbol .
                        context['ctx_number']=int(w[1]) # The context number is always after the first .

                        for tt in w: # Now we search if is a source replication context, or a destination replication context
                            if 'src_host' in tt:
                                context['src_host']=context_list[1]
                                self.replication_contexts.append(context)
                            elif 'src_path' in tt:
                                context['src_path']=context_list[1]
                                self.replication_contexts.append(context)

                            elif 'dst_host' in tt:
                                context['dst_host']=context_list[1]
                                self.replication_contexts.append(context)

                            elif 'dst_path' in tt:
                                    context['dst_path']=context_list[1]
                                    self.replication_contexts.append(context)
                        context={}

        # Now I am changing the format, so self.replication_contexts is a list of Dictionaries
        # where each dictionary in the list represents fully a unique content.
        # in contrast with what we have right now where there are several dictionaries across the list
        # representing different just part of the information from a replication context and the view is not clear
        context_list=[]
        context_list_unique=[]

        # I obtain a list with the number of contexts
        for itera in self.replication_contexts: # itera is an iterator dictionary
            print(itera)
            context_list.append(itera['ctx_number'])
        list_set=set(context_list) # I need to obtain just unique values, so I make a set
        context_list_unique=list(list_set) # and from that set a list
        print('contest_list_unique: {}'.format(context_list_unique))
        self.num_of_replication_contexts=len(context_list_unique) # I update the class attribute num_of_replication_contexts

        # Here is where I do start to change the representation view
        """
        # So far self.replication_contexts is just a list of dictionaries

        {'dst_host': ' atl0san03.corp.autoclubfl.com', 'ctx_number': 1}
        {'dst_path': ' /data/col1/sql_tpa0', 'ctx_number': 1}
        {'ctx_number': 1, 'src_host': ' tpa0san03.corp.autoclubfl.com'}
        {'ctx_number': 1, 'src_path': ' /data/col1/sql'}
        {'dst_host': ' atl0san03.corp.autoclubfl.com', 'ctx_number': 2}
        {'dst_path': ' /data/col1/veeam_tpa0', 'ctx_number': 2}
        {'ctx_number': 2, 'src_host': ' tpa0san03.corp.autoclubfl.com'}
        {'ctx_number': 2, 'src_path': ' /data/col1/veeam'}

        """
        # I need to transform it to look like

        """
        repl_ctx_list = [
                {'ctx': 1,
                 'source': {
                     'host': 'dd390gcsr01.nam.nsroot.net',
                     'mtree': '/data/col1/dd390gcsr01_crebm4900_lsu1_rep',
                     },
                 'destination': {
                     'host': 'dd390gcsr02.nam.nsroot.net',
                     'mtree': '/data/col1/dd390gcsr01_crebm4900_lsu1_rep'
                    }
                },
                {'ctx': 2,
                 'source': {
                     'host': 'dd390gcsr01.nam.nsroot.net',
                     'mtree': '/data/col1/dd390gcsr01_crebm4900_lsu2_rep',
                     },
                 'destination': {
                     'host': 'dd390gcsr02.nam.nsroot.net',
                     'mtree': '/data/col1/dd390gcsr01_crebm4900_lsu2_rep'
                     }
        """
        temporal_context={}
        temporal_list=[]
        for j in self.replication_contexts: # for each dictionary in the list
            print j
        for i in context_list_unique: # for each context
            for j in self.replication_contexts: # I do search in the old format list of dictionaries

                if j["ctx_number"]==i: #Voy buscando solo la informacion del context i en el churro de diccionarios que tengo
                    temporal_context['ctx_number']=i # voy a crear la estructura del contexto i
                    if 'src_host' in j: # checking if the key is in the dictionary
                        print("hola {}".format(j))
                        print("source host {}".format(j['src_host']))
                        temporal_context['ssource']={'hgost':j['src_host']}

                    if 'src_path' in j:
                        print("hola {}".format(j))
                        print("source path {}".format(j['src_path']))
                        temporal_context['source']={'mtree':j['src_path']}


                    if 'dst_host' in j:
                        temporal_context['destination']={'host':j['dst_host']}
                #        temporal_context['dst_host']=j['dst_host']

                    if 'dst_path' in j:
                            temporal_context['dst_path']={'mtree':j['dst_path']}
                #        temporal_context['dst_path']=j['dst_path']
            print("el contexto temporal {}".format(temporal_context))
            temporal_list.append(temporal_context) # temporal context here contains a dictionary with the full information of a context, so we add to the list
            temporal_context={} # we clear the dictionary as we are going to iterate to the next context
        self.replication_contexts=temporal_list # when we have finish we update the class attribute replication_contexts
    # This function prints an specific replication context
    def print_replication_context(self,context_number):
        # Toda la informacion del contexto 1
        for itera in self.replication_contexts:
            if(itera["ctx_number"]==context_number):
                if 'src_host' in itera:
                    print('src_host:{}').format(itera['src_host'])
                if 'src_path' in itera:
                    print('src_path:{}').format(itera['src_path'])
                if 'dst_host' in itera:
                    print('dst_host:{} ').format(itera['dst_host'])
                if 'dst_path' in itera:
                    print('dst_path:{}').format(itera['dst_path'])

    # Returns a list with the information of an specific context
    def get_lrepl_client_time_stats(self,replication_context_number):
        context_to_search="rctx://"+str(replication_context_number)
        for i in range(1,len(self.lrepl_client_time_stats)): # empezamos en 1 poraue el 0 es la cabecera
            if self.lrepl_client_time_stats[i][0]==context_to_search:
                return(self.lrepl_client_time_stats[i])
    # This method populates the lrep_client_time_stats class member
    def populate_lrepl_client_time_stats(self,start_delimiter,end_delimiter):

        found_start = False # A trigger variable
        found_end = False # Trigger variable
        data=[] # A list storing the information that we are reading from the autosupport

        # If we have a DD OS version, we can continue defining the delimiters
        # We are searching for the information about the contexts, and that is stored in the autosupport
        # between the delimiters 'Lrepl client time stats' and 'Lrepl client stream stats'

        with open (self.current_autosupport_name) as autosupport_file:
            for line in autosupport_file:
                if start_delimiter in line:  # We found the start_delimiter, now we search until the start of the Lrepl client time stats
                    print(line)
                    found_start = True
                    for line in autosupport_file:  # And once we find it, we read until the end of the relevant information (
                        if end_delimiter in line:  # We exit here as we have all the information we need
                            found_end=True
                            break
                        else:

                            if not (line.isspace()): # We do not want to add to the data empty strings
                                data.append(line.strip().split())  # We store information in a list called data
        if(found_start and found_end):
            self.lrepl_client_time_stats=data
        else:
            return (-1)
